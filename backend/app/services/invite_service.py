"""Invite service â€“ referral code generation and redemption."""

import secrets
from datetime import datetime, timedelta, timezone
from uuid import UUID

import structlog
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.invite import Invite
from app.models.subscription import Subscription
from app.models.user import User

logger = structlog.get_logger()

BOT_NAME = "nutrimind_bot"
PREMIUM_DAYS = 7


def _generate_code(length: int = 8) -> str:
    """Generate a URL-safe random invite code."""
    return secrets.token_urlsafe(length)[:length].upper()


def build_share_url(code: str) -> str:
    """Build the Telegram deep-link share URL for an invite code."""
    return f"https://t.me/{BOT_NAME}?start=invite_{code}"


async def generate_invite(
    db: AsyncSession,
    user_id: UUID,
) -> Invite:
    """Generate a unique invite code for the user."""
    # Generate a unique code (retry on collision)
    for _ in range(5):
        code = _generate_code()
        existing = await db.execute(
            select(Invite).where(Invite.invite_code == code)
        )
        if existing.scalar_one_or_none() is None:
            break
    else:
        raise RuntimeError("Failed to generate unique invite code after 5 attempts")

    invite = Invite(
        inviter_id=user_id,
        invite_code=code,
    )
    db.add(invite)
    await db.flush()

    logger.info("invite_generated", user_id=str(user_id), code=code)
    return invite


async def _award_premium(db: AsyncSession, user_id: UUID) -> None:
    """Award 7-day premium to a user.

    If the user already has premium with a later expiry, extend by 7 days
    from that expiry instead.
    """
    now = datetime.now(timezone.utc)
    bonus = timedelta(days=PREMIUM_DAYS)

    user = await db.get(User, user_id)
    if user is None:
        logger.warning("award_premium_user_not_found", user_id=str(user_id))
        return

    # Determine the new expiry date
    if (
        user.subscription_status == "premium"
        and user.subscription_expires_at is not None
        and user.subscription_expires_at > now
    ):
        # Extend from current expiry
        new_expiry = user.subscription_expires_at + bonus
    else:
        # Start fresh from now
        new_expiry = now + bonus

    # Create a subscription record
    sub = Subscription(
        user_id=user_id,
        plan="premium",
        provider="invite",
        status="active",
        expires_at=new_expiry,
    )
    db.add(sub)

    # Update user fields
    user.subscription_status = "premium"
    user.subscription_expires_at = new_expiry

    await db.flush()

    logger.info(
        "premium_awarded",
        user_id=str(user_id),
        expires_at=new_expiry.isoformat(),
    )


async def redeem_invite(
    db: AsyncSession,
    invite_code: str,
    invitee_id: UUID,
) -> Invite | None:
    """Redeem an invite code.

    Returns the invite if successfully redeemed, or None if the code
    is invalid or already used.

    Awards 7-day premium to both inviter and invitee.
    """
    stmt = select(Invite).where(Invite.invite_code == invite_code)
    result = await db.execute(stmt)
    invite = result.scalar_one_or_none()

    if invite is None:
        logger.warning("invite_not_found", code=invite_code)
        return None

    if invite.invitee_id is not None:
        logger.warning("invite_already_redeemed", code=invite_code)
        return None

    if invite.inviter_id == invitee_id:
        logger.warning("invite_self_redeem", code=invite_code, user_id=str(invitee_id))
        return None

    invite.invitee_id = invitee_id
    invite.redeemed_at = datetime.now(timezone.utc)
    await db.flush()

    # Award 7-day premium to both parties
    await _award_premium(db, invite.inviter_id)
    await _award_premium(db, invitee_id)

    logger.info(
        "invite_redeemed",
        code=invite_code,
        inviter_id=str(invite.inviter_id),
        invitee_id=str(invitee_id),
        premium_days=PREMIUM_DAYS,
    )
    return invite


async def get_my_invites(db: AsyncSession, user_id: UUID) -> dict:
    """Return all invites generated by the user with redemption status."""
    stmt = (
        select(Invite)
        .where(Invite.inviter_id == user_id)
        .order_by(Invite.created_at.desc())
    )
    result = await db.execute(stmt)
    invites = result.scalars().all()

    invite_list = []
    total_redeemed = 0
    for inv in invites:
        redeemed = inv.invitee_id is not None
        if redeemed:
            total_redeemed += 1
        invite_list.append({
            "id": inv.id,
            "invite_code": inv.invite_code,
            "share_url": build_share_url(inv.invite_code),
            "redeemed": redeemed,
            "invitee_id": inv.invitee_id,
            "redeemed_at": inv.redeemed_at,
            "created_at": inv.created_at,
        })

    return {
        "invites": invite_list,
        "total_redeemed": total_redeemed,
    }
